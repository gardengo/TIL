## 목차

1. [배열 (Array)](#배열-array)
2. [연결 리스트 (Linked List)](#연결-리스트-linked-list)
   - 2.1. [단일 연결 리스트 (Singly Linked List)](#21-단일-연결-리스트-singly-linked-list)
   - 2.2. [이중 연결 리스트 (Doubly Linked List)](#22-이중-연결-리스트-doubly-linked-list)
3. [스택 (Stack)](#스택-stack)
4. [큐 (Queue)](#큐-queue)
   - 4.1. [원형 큐 (Circular Queue)](#41-원형-큐-circular-queue)
   - 4.2. [우선순위 큐 (Priority Queue)](#42-우선순위-큐-priority-queue)
5. [덱 (Deque)](#덱-deque)
6. [해시 테이블 (Hash Table)](#해시-테이블-hash-table)
7. [힙 (Heap)](#힙-heap)
8. [트리 (Tree)](#트리-tree)
   - 8.1. [이진 트리 (Binary Tree)](#81-이진-트리-binary-tree)
   - 8.2. [이진 탐색 트리 (Binary Search Tree)](#82-이진-탐색-트리-binary-search-tree)
   - 8.3. [힙 트리 (Heap Tree)](#83-힙-트리-heap-tree)
9. [그래프 (Graph)](#그래프-graph)
10. [트라이 (Trie)](#트라이-trie)
11. [유니온 파인드 (Union-Find)](#유니온-파인드-union-find)

---

## 배열 (Array)

### 기본 개념 및 특징
배열은 동일한 타입의 요소들이 연속된 메모리 공간에 저장되는 자료구조입니다. 인덱스를 통해 빠르게 접근할 수 있으며, 고정된 크기를 가지거나 동적으로 크기를 조절할 수 있습니다.

### 파이썬에서의 특징
파이썬의 `list`는 배열을 구현한 것으로, **동적 크기**를 지원하며 **다양한 데이터 타입**을 저장할 수 있습니다. 또한, 다양한 내장 메소드가 제공되어 배열 조작이 용이합니다.

### 주요 메소드

| 메소드          | 설명                                                                 | 시간복잡도        |
|-----------------|----------------------------------------------------------------------|-------------------|
| `append(x)`     | 배열의 끝에 요소 `x`를 추가합니다.                                    | O(1) 평균          |
| `insert(i, x)`  | 인덱스 `i` 위치에 요소 `x`를 삽입합니다.                             | O(n)               |
| `remove(x)`     | 첫 번째로 나타나는 요소 `x`를 제거합니다.                            | O(n)               |
| `pop([i])`      | 인덱스 `i`의 요소를 제거하고 반환합니다. 인덱스를 지정하지 않으면 마지막 요소를 제거합니다. | O(1) (마지막 요소), O(n) (특정 인덱스) |
| `index(x)`      | 요소 `x`의 첫 번째 인덱스를 반환합니다.                               | O(n)               |
| `count(x)`      | 요소 `x`의 개수를 반환합니다.                                         | O(n)               |
| `sort()`        | 배열을 정렬합니다.                                                     | O(n log n)         |
| `reverse()`     | 배열의 요소 순서를 뒤집습니다.                                        | O(n)               |
| `extend(iterable)` | 배열의 끝에 iterable의 모든 요소를 추가합니다.                      | O(k) (k는 추가 요소의 수) |

### 공간 복잡도
- O(n)

### 사용 사례
- 데이터의 순차적 저장 및 접근
- 스택이나 큐의 기반 자료구조로 사용
- 동적 배열 구현

### 구현 방법
파이썬에서는 기본적으로 `list`를 사용하여 배열을 구현합니다.

```python
# 배열 생성
array = [1, 2, 3, 4, 5]

# 배열 조작 예시
array.append(6)        # [1, 2, 3, 4, 5, 6]
array.insert(0, 0)     # [0, 1, 2, 3, 4, 5, 6]
removed = array.pop()  # removed = 6, array = [0, 1, 2, 3, 4, 5]
```

---

## 연결 리스트 (Linked List)

### 기본 개념 및 특징
연결 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가지는 자료구조입니다. 동적으로 크기를 조절할 수 있으며, 삽입과 삭제가 용이합니다.

### 파이썬에서의 특징
파이썬에는 기본적으로 연결 리스트가 내장되어 있지 않지만, 클래스를 사용하여 쉽게 구현할 수 있습니다. `list`와는 달리 노드 단위로 메모리가 할당되어 유연한 데이터 조작이 가능합니다.

### 주요 메소드

| 메소드                          | 설명                                           | 시간복잡도   |
|---------------------------------|------------------------------------------------|--------------|
| `append(data)`                  | 리스트의 끝에 새로운 노드를 추가합니다.          | O(n)         |
| `prepend(data)`                 | 리스트의 시작 부분에 새로운 노드를 추가합니다.    | O(1)         |
| `insert_after_node(prev_node, data)` | 특정 노드 뒤에 새로운 노드를 삽입합니다.       | O(1)         |
| `delete_node(key)`              | 특정 값을 가진 노드를 삭제합니다.                | O(n)         |
| `print_list()`                  | 리스트의 모든 요소를 출력합니다.                | O(n)         |

### 공간 복잡도
- O(n)

### 사용 사례
- 동적 데이터 저장
- 스택과 큐의 구현
- 그래프의 인접 리스트 표현

### 구현 방법

#### 2.1. 단일 연결 리스트 (Singly Linked List)

단일 연결 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터만을 가지는 구조입니다.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_after_node(self, prev_node, data):
        if not prev_node:
            print("이전 노드는 반드시 존재해야 합니다.")
            return
        new_node = Node(data)
        new_node.next = prev_node.next
        prev_node.next = new_node

    def delete_node(self, key):
        temp = self.head
        if temp and temp.data == key:
            self.head = temp.next
            temp = None
            return
        prev = None
        while temp and temp.data != key:
            prev = temp
            temp = temp.next
        if not temp:
            return
        prev.next = temp.next
        temp = None

    def print_list(self):
        temp = self.head
        while temp:
            print(temp.data, end=" -> ")
            temp = temp.next
        print("None")
```

#### 2.2. 이중 연결 리스트 (Doubly Linked List)

이중 연결 리스트는 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 가지는 구조입니다.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node
        new_node.prev = last

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        if self.head:
            self.head.prev = new_node
        self.head = new_node

    def insert_after_node(self, prev_node, data):
        if not prev_node:
            print("이전 노드는 반드시 존재해야 합니다.")
            return
        new_node = Node(data)
        new_node.next = prev_node.next
        new_node.prev = prev_node
        if prev_node.next:
            prev_node.next.prev = new_node
        prev_node.next = new_node

    def delete_node(self, node):
        if not node:
            return
        if node.prev:
            node.prev.next = node.next
        else:
            self.head = node.next
        if node.next:
            node.next.prev = node.prev
        node = None

    def print_list(self):
        temp = self.head
        while temp:
            print(temp.data, end=" <-> ")
            temp = temp.next
        print("None")
```

---

## 스택 (Stack)

### 기본 개념 및 특징
스택은 후입선출(LIFO) 방식으로 데이터를 관리하는 자료구조입니다. 주로 함수 호출 관리, 역순 처리 등에 사용됩니다.

### 파이썬에서의 특징
파이썬에서는 `list`나 `collections.deque`를 사용하여 스택을 구현할 수 있습니다. `list`는 간단한 스택 구현에 적합하며, `deque`는 더 나은 성능을 제공합니다.

### 주요 메소드

| 메소드        | 설명                                       | 시간복잡도 |
|---------------|--------------------------------------------|------------|
| `append(x)`   | 스택의 끝에 요소 `x`를 추가합니다. (`push` 역할) | O(1)       |
| `pop()`       | 스택의 끝에서 요소를 제거하고 반환합니다. (`pop` 역할) | O(1)       |
| `extend(iterable)` | 스택의 끝에 여러 요소를 추가합니다.               | O(k)       |
| `clear()`     | 스택의 모든 요소를 제거합니다.                  | O(n)       |
| `copy()`      | 스택의 복사본을 반환합니다.                     | O(n)       |
| `count(x)`    | 스택 내에 요소 `x`의 개수를 반환합니다.           | O(n)       |
| `index(x)`    | 스택에서 요소 `x`의 첫 번째 인덱스를 반환합니다.    | O(n)       |

**참고:** 기본적으로 `list`에는 `peek()` 메소드가 없지만, 최상위 요소를 확인하려면 `stack[-1]`을 사용할 수 있습니다.

### 공간 복잡도
- O(n)

### 사용 사례
- 함수 호출 스택
- 괄호 검사
- 역순 데이터 처리

### 구현 방법
파이썬에서는 `list` 또는 `collections.deque`를 사용하여 스택을 구현할 수 있습니다.

```python
# 리스트를 이용한 스택 구현
stack = []
stack.append(1)  # push
stack.append(2)
top = stack.pop()  # pop, top = 2
peek = stack[-1]   # peek, peek = 1

# deque를 이용한 스택 구현
from collections import deque
stack = deque()
stack.append(1)
stack.append(2)
top = stack.pop()      # pop, top = 2
peek = stack[-1]       # peek, peek = 1
```

---

## 큐 (Queue)

### 기본 개념 및 특징
큐는 선입선출(FIFO) 방식으로 데이터를 관리하는 자료구조입니다. 주로 BFS, 작업 스케줄링 등에 사용됩니다.

### 파이썬에서의 특징
파이썬에서는 `collections.deque`를 사용하여 큐를 효율적으로 구현할 수 있습니다. `deque`는 양쪽 끝에서 빠른 삽입과 삭제를 지원합니다.

### 주요 메소드

| 메소드        | 설명                                      | 시간복잡도 |
|---------------|-------------------------------------------|------------|
| `append(x)`   | 큐의 끝에 요소 `x`를 추가합니다. (`enqueue` 역할) | O(1)       |
| `popleft()`   | 큐의 앞에서 요소를 제거하고 반환합니다. (`dequeue` 역할) | O(1)       |
| `extend(iterable)` | 큐의 끝에 여러 요소를 추가합니다.              | O(k)       |
| `clear()`     | 큐의 모든 요소를 제거합니다.                  | O(n)       |
| `copy()`      | 큐의 복사본을 반환합니다.                     | O(n)       |
| `count(x)`    | 큐 내에 요소 `x`의 개수를 반환합니다.           | O(n)       |
| `remove(x)`   | 큐에서 첫 번째로 나타나는 요소 `x`를 제거합니다. | O(n)       |
| `rotate(n)`   | 큐를 `n`만큼 회전시킵니다.                    | O(k)       |

**참고:** `front()` 메소드는 존재하지 않지만, `queue[0]`을 통해 큐의 앞 요소를 확인할 수 있습니다.

### 공간 복잡도
- O(n)

### 사용 사례
- BFS(너비 우선 탐색)
- 작업 스케줄링
- 캐시 구현

### 구현 방법
파이썬에서는 `collections.deque`를 사용하여 큐를 효율적으로 구현할 수 있습니다.

```python
from collections import deque

# 큐 구현
queue = deque()
queue.append(1)        # enqueue
queue.append(2)
front = queue.popleft()  # dequeue, front = 1
```

#### 4.1. 원형 큐 (Circular Queue)

##### 기본 개념 및 특징
원형 큐는 고정된 크기의 큐로, 끝이 닫혀 처음으로 돌아갑니다. 메모리를 효율적으로 사용하며, 고정된 크기 내에서 반복적으로 사용할 수 있습니다.

##### 파이썬에서의 특징
파이썬에서는 `deque`를 사용하여 원형 큐를 구현할 수 있으며, 최대 길이를 설정하여 고정 크기의 큐를 만들 수 있습니다.

##### 주요 메소드

| 메소드       | 설명                                      | 시간복잡도 |
|--------------|-------------------------------------------|------------|
| `append(data)` | 큐의 끝에 데이터를 추가합니다. (`enqueue` 역할) | O(1)       |
| `popleft()`    | 큐의 앞에서 데이터를 제거하고 반환합니다. (`dequeue` 역할) | O(1)       |

##### 공간 복잡도
- O(n)

##### 사용 사례
- 고정된 메모리 내에서의 큐 구현
- 순환 버퍼

##### 구현 방법

```python
from collections import deque

class CircularQueue:
    def __init__(self, size):
        self.queue = deque(maxlen=size)
        self.size = size

    def enqueue(self, data):
        if len(self.queue) == self.size:
            raise OverflowError("Queue is full")
        self.queue.append(data)

    def dequeue(self):
        if not self.queue:
            raise IndexError("Queue is empty")
        return self.queue.popleft()

# 사용 예시
cq = CircularQueue(3)
cq.enqueue(1)
cq.enqueue(2)
cq.enqueue(3)
# cq.enqueue(4)  # OverflowError
print(cq.dequeue())  # 1
cq.enqueue(4)
print(cq.queue)       # deque([2, 3, 4], maxlen=3)
```

#### 4.2. 우선순위 큐 (Priority Queue)

##### 기본 개념 및 특징
우선순위 큐는 각 요소가 우선순위를 가지며, 높은 우선순위를 가진 요소가 먼저 제거되는 큐입니다. 일반적인 큐와 달리 요소의 삽입 순서가 아닌 우선순위에 따라 요소가 처리됩니다.

##### 파이썬에서의 특징
파이썬에서는 `heapq` 모듈을 사용하여 우선순위 큐를 구현할 수 있습니다. `heapq`는 최소 힙을 기본으로 하며, 튜플의 첫 번째 요소를 기준으로 우선순위를 결정합니다.

##### 주요 메소드

| 메소드                 | 설명                                                   | 시간복잡도 |
|------------------------|--------------------------------------------------------|------------|
| `heappush(heap, item)` | 힙에 아이템을 추가합니다.                                | O(log n)   |
| `heappop(heap)`        | 힙에서 가장 작은 아이템을 제거하고 반환합니다.          | O(log n)   |
| `heapify(x)`           | 리스트를 힙으로 변환합니다.                              | O(n)       |
| `heappushpop(heap, item)` | 아이템을 힙에 추가한 후, 가장 작은 아이템을 제거하고 반환합니다. | O(log n)   |
| `heapreplace(heap, item)` | 힙에서 가장 작은 아이템을 제거하고, 새로운 아이템을 추가합니다. | O(log n)   |

### 공간 복잡도
- O(n)

### 사용 사례
- 다익스트라 알고리즘
- 작업 스케줄링
- 실시간 이벤트 관리

### 구현 방법
파이썬의 `heapq` 모듈을 사용하여 우선순위 큐를 구현할 수 있습니다.

```python
import heapq

# 우선순위 큐 구현
priority_queue = []
heapq.heappush(priority_queue, (2, 'code'))
heapq.heappush(priority_queue, (1, 'eat'))
heapq.heappush(priority_queue, (3, 'sleep'))

first = heapq.heappop(priority_queue)  # (1, 'eat')
print(first)  # 출력: (1, 'eat')
```

---

## 덱 (Deque)

### 기본 개념 및 특징
덱(Double-Ended Queue)은 양쪽 끝에서 삽입과 삭제가 가능한 자료구조입니다. 스택과 큐의 기능을 모두 포함하며, 양방향에서의 효율적인 데이터 처리가 가능합니다.

### 파이썬에서의 특징
파이썬에서는 `collections.deque`를 사용하여 덱을 구현할 수 있습니다. `deque`는 스레드에 안전하며, 양쪽 끝에서의 빠른 삽입과 삭제를 지원합니다.

### 주요 메소드

| 메소드               | 설명                                         | 시간복잡도 |
|----------------------|----------------------------------------------|------------|
| `append(x)`          | 덱의 오른쪽에 요소 `x`를 추가합니다.         | O(1)       |
| `appendleft(x)`      | 덱의 왼쪽에 요소 `x`를 추가합니다.           | O(1)       |
| `pop()`              | 덱의 오른쪽에서 요소를 제거하고 반환합니다.   | O(1)       |
| `popleft()`          | 덱의 왼쪽에서 요소를 제거하고 반환합니다.     | O(1)       |
| `extend(iterable)`   | 덱의 오른쪽에 여러 요소를 추가합니다.        | O(k)       |
| `extendleft(iterable)` | 덱의 왼쪽에 여러 요소를 추가합니다.         | O(k)       |
| `rotate(n)`          | 덱을 `n`만큼 회전시킵니다.                    | O(k)       |

### 공간 복잡도
- O(n)

### 사용 사례
- 양쪽 끝에서 삽입과 삭제가 필요한 경우
- 슬라이딩 윈도우 알고리즘
- BFS에서의 양방향 탐색

### 구현 방법
파이썬의 `collections.deque`를 사용하여 덱을 구현할 수 있습니다.

```python
from collections import deque

# 덱 구현
deque_obj = deque()
deque_obj.append(1)        # 오른쪽에 추가
deque_obj.appendleft(2)    # 왼쪽에 추가
right = deque_obj.pop()    # 오른쪽에서 제거, right = 1
left = deque_obj.popleft() # 왼쪽에서 제거, left = 2
print(deque_obj)           # deque([])
```

---

## 해시 테이블 (Hash Table)

### 기본 개념 및 특징
해시 테이블은 키-값 쌍을 효율적으로 저장하고 검색할 수 있는 자료구조입니다. 해시 함수를 사용하여 키를 인덱스로 변환하고, 이를 통해 빠른 접근을 가능하게 합니다.

### 파이썬에서의 특징
파이썬에서는 `dict`가 해시 테이블을 구현한 것입니다. `dict`는 **동적 크기**를 가지며 **해시 충돌**을 처리하기 위한 다양한 최적화가 내장되어 있습니다. 또한, 순서가 보장되는(파이썬 3.7 이상) **순서가 있는 사전**입니다.

### 주요 메소드

| 메소드                      | 설명                                               | 시간복잡도  |
|-----------------------------|----------------------------------------------------|-------------|
| `__setitem__(key, value)`   | 키에 값을 할당합니다. (`hash_table[key] = value`)    | O(1) 평균  |
| `__getitem__(key)`          | 키에 해당하는 값을 반환합니다. (`hash_table[key]`)    | O(1) 평균  |
| `get(key, default)`         | 키에 해당하는 값을 반환하거나, 기본값을 반환합니다.    | O(1) 평균  |
| `keys()`                    | 모든 키를 반환합니다.                                | O(n)        |
| `values()`                  | 모든 값을 반환합니다.                                | O(n)        |
| `items()`                   | 모든 키-값 쌍을 반환합니다.                          | O(n)        |
| `pop(key)`                  | 키에 해당하는 값을 제거하고 반환합니다.               | O(1) 평균  |
| `clear()`                   | 모든 키-값 쌍을 제거합니다.                          | O(n)        |
| `update(other)`             | 다른 딕셔너리의 키-값 쌍을 추가하거나 업데이트합니다. | O(k)        |
| `setdefault(key, default)`  | 키가 없으면 기본값을 설정하고 반환합니다.            | O(1) 평균  |
| `copy()`                    | 딕셔너리의 복사본을 반환합니다.                      | O(n)        |

### 공간 복잡도
- O(n)

### 사용 사례
- 빠른 데이터 검색
- 캐시 구현 (예: LRU 캐시)
- 데이터 매핑

### 구현 방법
파이썬의 `dict`를 사용하여 해시 테이블을 구현할 수 있습니다.

```python
# 해시 테이블 구현
hash_table = {}
hash_table['key1'] = 'value1'
hash_table['key2'] = 'value2'
value = hash_table.get('key1')  # 'value1'

# 해시 테이블 조작 예시
hash_table['key3'] = 'value3'
hash_table.pop('key2')          # 'value2' 제거
print(hash_table)               # {'key1': 'value1', 'key3': 'value3'}
```

---

## 힙 (Heap)

### 기본 개념 및 특징
힙은 완전 이진 트리의 일종으로, 부모 노드가 자식 노드보다 크거나 작은 특성을 가지는 자료구조입니다. 최소 힙과 최대 힙이 있으며, 우선순위 큐 구현에 주로 사용됩니다.

### 파이썬에서의 특징
파이썬에서는 `heapq` 모듈을 사용하여 힙을 구현할 수 있습니다. `heapq`는 최소 힙을 기본으로 하며, 리스트를 힙 구조로 유지합니다. 최대 힙을 구현하려면 값에 부호를 반전시켜 사용할 수 있습니다.

### 주요 메소드

| 메소드                | 설명                                                 | 시간복잡도 |
|-----------------------|------------------------------------------------------|------------|
| `heappush(heap, item)` | 힙에 아이템을 추가합니다.                              | O(log n)   |
| `heappop(heap)`        | 힙에서 가장 작은 아이템을 제거하고 반환합니다.         | O(log n)   |
| `heapify(x)`           | 리스트를 힙으로 변환합니다.                            | O(n)       |
| `heappushpop(heap, item)` | 아이템을 힙에 추가한 후, 가장 작은 아이템을 제거하고 반환합니다. | O(log n)   |
| `heapreplace(heap, item)` | 힙에서 가장 작은 아이템을 제거하고, 새로운 아이템을 추가합니다. | O(log n)   |

### 공간 복잡도
- O(n)

### 사용 사례
- 우선순위 큐
- 다익스트라 알고리즘
- 힙 정렬

### 구현 방법
파이썬의 `heapq` 모듈을 사용하여 힙을 구현할 수 있습니다.

```python
import heapq

# 힙 구현
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 2)

smallest = heapq.heappop(heap)  # 1
print(smallest)  # 출력: 1

heapq.heapify([5, 3, 8, 1, 2])
print(heap)  # 출력: [1, 2, 8, 5, 3]
```

---

## 트리 (Tree)

### 기본 개념 및 특징
트리는 계층적 구조를 가지는 자료구조로, 노드들이 부모-자식 관계를 통해 연결됩니다. 다양한 형태의 트리가 있으며, 데이터의 효율적인 검색과 저장에 사용됩니다.

### 파이썬에서의 특징
파이썬에서는 트리를 기본적으로 지원하지 않지만, 클래스를 사용하여 다양한 형태의 트리를 쉽게 구현할 수 있습니다. 재귀적인 구조로 트리 탐색 알고리즘을 구현하기 용이합니다.

### 주요 메소드

| 메소드                      | 설명                                       | 시간복잡도                 |
|-----------------------------|--------------------------------------------|----------------------------|
| `insert(data)`               | 데이터를 삽입합니다.                        | O(log n) 평균, O(n) 최악  |
| `search(data)`               | 데이터를 검색합니다.                        | O(log n) 평균, O(n) 최악  |
| `delete(data)`               | 데이터를 삭제합니다.                        | O(log n) 평균, O(n) 최악  |
| `inorder_traversal()`        | 중위 순회                                 | O(n)                       |
| `preorder_traversal()`       | 전위 순회                                 | O(n)                       |
| `postorder_traversal()`      | 후위 순회                                 | O(n)                       |

### 공간 복잡도
- O(n)

### 사용 사례
- 계층적 데이터 저장
- 데이터베이스 인덱스
- 표현식 트리

### 구현 방법

#### 8.1. 이진 트리 (Binary Tree)

이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리 구조입니다.

```python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# 이진 트리 생성
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)

# 중위 순회 예시
def inorder_traversal(node):
    if node:
        inorder_traversal(node.left)
        print(node.data, end=' ')
        inorder_traversal(node.right)

inorder_traversal(root)  # 출력: 2 1 3
```

#### 8.2. 이진 탐색 트리 (Binary Search Tree)

이진 탐색 트리는 모든 왼쪽 자식이 부모보다 작고, 모든 오른쪽 자식이 부모보다 큰 특성을 가지는 트리입니다.

```python
class BSTNode:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, data):
        if not self.root:
            self.root = BSTNode(data)
            return
        self._insert(self.root, data)

    def _insert(self, node, data):
        if data < node.data:
            if node.left:
                self._insert(node.left, data)
            else:
                node.left = BSTNode(data)
        else:
            if node.right:
                self._insert(node.right, data)
            else:
                node.right = BSTNode(data)

    def search(self, data):
        return self._search(self.root, data)

    def _search(self, node, data):
        if not node or node.data == data:
            return node
        if data < node.data:
            return self._search(node.left, data)
        return self._search(node.right, data)

    def inorder_traversal(self):
        self._inorder_traversal(self.root)
        print()

    def _inorder_traversal(self, node):
        if node:
            self._inorder_traversal(node.left)
            print(node.data, end=' ')
            self._inorder_traversal(node.right)

# 사용 예시
bst = BinarySearchTree()
bst.insert(5)
bst.insert(3)
bst.insert(7)
bst.insert(2)
bst.insert(4)
bst.insert(6)
bst.insert(8)

bst.inorder_traversal()  # 출력: 2 3 4 5 6 7 8
found = bst.search(4)
print(found.data if found else "Not found")  # 출력: 4
```

#### 8.3. 힙 트리 (Heap Tree)

힙 트리는 부모 노드가 자식 노드보다 크거나 작은 특성을 가지는 완전 이진 트리입니다. 최소 힙과 최대 힙이 있으며, 우선순위 큐 구현에 사용됩니다.

파이썬에서는 `heapq` 모듈을 사용하여 힙을 구현할 수 있습니다.

```python
import heapq

# 최소 힙 구현
heap = []
heapq.heappush(heap, 10)
heapq.heappush(heap, 5)
heapq.heappush(heap, 20)

smallest = heapq.heappop(heap)  # 5
print(smallest)  # 출력: 5

# 최대 힙 구현 (부호를 반전시켜 사용)
max_heap = []
heapq.heappush(max_heap, -10)
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -20)

largest = -heapq.heappop(max_heap)  # 20
print(largest)  # 출력: 20
```

---

## 그래프 (Graph)

### 기본 개념 및 특징
그래프는 노드(정점)와 이들을 연결하는 간선으로 구성된 자료구조입니다. 방향성 여부에 따라 방향 그래프와 무방향 그래프로 구분되며, 가중치의 유무에 따라 가중 그래프와 비가중 그래프로 나뉩니다.

### 파이썬에서의 특징
파이썬에서는 인접 리스트나 인접 행렬을 사용하여 그래프를 구현할 수 있습니다. 일반적으로 `dict`를 사용한 인접 리스트가 더 효율적이며, 유연한 그래프 구조를 제공합니다.

### 주요 메소드

| 메소드            | 설명                                           | 시간복잡도 |
|-------------------|------------------------------------------------|------------|
| `add_edge(u, v)`  | 노드 `u`에서 노드 `v`로의 간선을 추가합니다.     | O(1) 평균  |
| `remove_edge(u, v)` | 노드 `u`에서 노드 `v`로의 간선을 제거합니다.   | O(E)       |
| `get_neighbors(u)` | 노드 `u`의 인접 노드를 반환합니다.              | O(1) 평균  |
| `print_graph()`    | 그래프를 출력합니다.                           | O(V + E)    |
| `bfs(start)`       | 너비 우선 탐색을 수행합니다.                   | O(V + E)    |
| `dfs(start)`       | 깊이 우선 탐색을 수행합니다.                   | O(V + E)    |

### 공간 복잡도
- 인접 리스트: O(V + E)
- 인접 행렬: O(V²)

### 사용 사례
- 소셜 네트워크
- 지도 및 네비게이션 시스템
- 네트워크 라우팅

### 구현 방법
파이썬에서는 인접 리스트나 인접 행렬을 사용하여 그래프를 구현할 수 있습니다. 여기서는 인접 리스트를 사용한 예제를 소개합니다.

```python
from collections import deque

class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v, directed=False):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)
        if not directed:
            if v not in self.graph:
                self.graph[v] = []
            self.graph[v].append(u)

    def remove_edge(self, u, v, directed=False):
        if u in self.graph and v in self.graph[u]:
            self.graph[u].remove(v)
        if not directed:
            if v in self.graph and u in self.graph[v]:
                self.graph[v].remove(u)

    def get_neighbors(self, u):
        return self.graph.get(u, [])

    def print_graph(self):
        for node in self.graph:
            print(node, ":", self.graph[node])

    def bfs(self, start):
        visited = set()
        queue = deque([start])
        visited.add(start)
        while queue:
            vertex = queue.popleft()
            print(vertex, end=" ")
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        print()

    def dfs(self, start):
        visited = set()
        stack = [start]
        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                print(vertex, end=" ")
                visited.add(vertex)
                for neighbor in reversed(self.get_neighbors(vertex)):
                    if neighbor not in visited:
                        stack.append(neighbor)
        print()

# 사용 예시
g = Graph()
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'D')
g.add_edge('D', 'E')

g.print_graph()
# 출력:
# A : ['B', 'C']
# B : ['A', 'D']
# C : ['A', 'D']
# D : ['B', 'C', 'E']
# E : ['D']

print("BFS Traversal:")
g.bfs('A')  # 출력: A B C D E 

print("DFS Traversal:")
g.dfs('A')  # 출력: A C D E B 
```

---

## 트라이 (Trie)

### 기본 개념 및 특징
트라이는 문자열을 저장하고 검색하는 데 효율적인 트리 기반 자료구조입니다. 주로 사전, 자동 완성 등에 사용되며, 공통 접두사를 공유함으로써 공간을 절약할 수 있습니다.

### 파이썬에서의 특징
파이썬에서는 클래스를 사용하여 트라이를 쉽게 구현할 수 있습니다. `dict`를 활용하여 각 노드의 자식 노드를 관리하며, 유연한 문자열 처리가 가능합니다.

### 주요 메소드

| 메소드                | 설명                                           | 시간복잡도 |
|-----------------------|------------------------------------------------|------------|
| `insert(word)`        | 단어를 트라이에 삽입합니다.                     | O(m)       |
| `search(word)`        | 단어가 트라이에 존재하는지 검색합니다.           | O(m)       |
| `starts_with(prefix)` | 주어진 접두사로 시작하는 단어가 있는지 확인합니다.| O(m)       |

### 공간 복잡도
- O(ALPHABET_SIZE * m * n), m은 단어의 평균 길이, n은 단어의 개수

### 사용 사례
- 자동 완성
- 사전 구현
- 문자열 검색

### 구현 방법

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

# 사용 예시
trie = Trie()
trie.insert("apple")
trie.insert("app")
print(trie.search("apple"))   # True
print(trie.search("app"))     # True
print(trie.search("apricot")) # False
print(trie.starts_with("ap")) # True
```

---

## 유니온 파인드 (Union-Find)

### 기본 개념 및 특징
유니온 파인드는 집합의 합집합과 찾기 연산을 효율적으로 처리하는 자료구조입니다. 주로 네트워크 연결성 검사, 최소 신장 트리 알고리즘 등에 사용됩니다.

### 파이썬에서의 특징
파이썬에서는 클래스를 사용하여 유니온 파인드를 구현할 수 있습니다. 경로 압축과 랭크를 활용하여 거의 상수 시간에 가까운 성능을 달성할 수 있습니다.

### 주요 메소드

| 메소드              | 설명                                     | 시간복잡도                        |
|---------------------|------------------------------------------|-----------------------------------|
| `find(x)`           | 원소 `x`가 속한 집합의 대표를 찾습니다.      | 거의 상수 시간 (아커만 함수에 가까움) |
| `union(x, y)`       | 원소 `x`와 `y`가 속한 집합을 합칩니다.        | 거의 상수 시간                     |
| `connected(x, y)`   | 원소 `x`와 `y`가 같은 집합에 속해있는지 확인합니다.| 거의 상수 시간                     |

### 공간 복잡도
- O(n)

### 사용 사례
- 네트워크 연결성 검사
- 크루스칼 알고리즘 (최소 신장 트리)
- 동적 연결성 문제

### 구현 방법

```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size  # 랭크 최적화

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 경로 압축
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return
        # 랭크에 따라 트리를 병합
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        else:
            self.parent[root_y] = root_x
            if self.rank[root_x] == self.rank[root_y]:
                self.rank[root_x] += 1

    def connected(self, x, y):
        return self.find(x) == self.find(y)

# 사용 예시
uf = UnionFind(5)  # 원소 0, 1, 2, 3, 4
uf.union(0, 1)
uf.union(1, 2)
print(uf.connected(0, 2))  # True
print(uf.connected(0, 3))  # False
uf.union(3, 4)
print(uf.connected(3, 4))  # True
```

---